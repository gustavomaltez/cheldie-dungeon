import { getRandomId } from '@utils';

import { Component } from './Component';

/**
 * Represents an abstract entity.
 * - All entities **MUST** extends this class.
 */
export abstract class Entity {

  /**
   * A unique autogenerated identifier for the entity.
   */
  public readonly id: string;

  /**
   * An set of components attached to the entity.
   */
  private _components: Record<string, Component> = {};

  constructor() {
    this.id = getRandomId();
  }

  /**
   * Checks if the specified component is attached to the entity.
   * 
   * @param component The component class you want to check (you must pass the class, not an instance nor a name).
   * @returns Whether the entity has the component attached to it or not.
   */
  public hasComponent<ComponentType extends Component>(component: new () => ComponentType): boolean {
    const _component = this._components[component.prototype.constructor.name];
    return _component !== undefined;
  }

  /**
   * Checks if an list of components are attached to the entity.
   * 
   * @param components A list of components you want to check (you must pass the class, not an instance nor a name).
   * @returns Whether all the components are attached to the entity or not.
   */
  public hasComponents<ComponentType extends Component>(components: (new () => ComponentType)[]): boolean {
    return components.every(component => this.hasComponent(component));
  }

  /**
   * Gets a component attached to the entity. 
   * - Throws an error if the entity does not have the component.
   * - Use `hasComponent` to check if the entity has the component. 
   * - If the entity does not have the component, it is safe to assume that the component is not attached to the entity.
   * 
   * @example 
   * class Player extends Entity { }
   * class Health extends Component { }
   * class Position extends Component { }
   * 
   * const player = new Player();
   * player.addComponent(new Health()); // Attach the health component to the player entity.
   * const health = player.getComponent(Health); // Returns the health component.
   * const position = player.getComponent(Position); // Throws an error because the player doesn't have a position component.
   * 
   * @param component The component class you want to get (you must pass the class, not an instance nor a name).
   * @returns The component instance attached to this entity.
   */
  public getComponent<ComponentType extends Component>(component: new () => ComponentType): ComponentType {
    const _component = this._components[component.prototype.constructor.name];
    if (!_component) throw new Error(`Entity ${this.id} has no component ${component.constructor.name}`);
    return _component as ComponentType;
  }

  /**
   * Retrieves all components attached to the entity.
   */
  public get components(): Record<string, Component> {
    return this._components;
  }

  /**
   * Attaches a component to the entity.
   * - If the entity already has the component attached, it will be replaced with the new one.
   * 
   * @example
   * class Player extends Entity { }
   * class Health extends Component { }
   * 
   * const player = new Player();
   * player.addComponent(new Health()); 
   * 
   * @param component A component instance you want to attach to the entity.
   */
  public addComponent(component: Component): void {
    component.entity = this;
    this._components[component.constructor.name] = component;
  }

  /**
   * Detaches a component to the entity.
   * 
   * @example
   * class Player extends Entity { }
   * class Health extends Component { }
   * 
   * const player = new Player();
   * player.addComponent(new Health());
   * player.removeComponent(Health); 
   * 
   * @param component The component class you want to remove (you must pass the class, not an instance nor a name).
   */
  public removeComponent<ComponentType extends Component>(component: new () => ComponentType): void {
    delete this._components[component.constructor.name];
  }
}